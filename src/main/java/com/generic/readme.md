# 泛型 <标签>
- 异常类不能为泛型类
- 没有new T[]的用法！！！
- 子类对父类的泛型是否擦除或者保留 Country<E, T>
    1. 擦除，即 China extends Country // 没有使用泛型
    2. 指定类型， 即 Usa extends Country<West, developed>  // 西方国家,发达国家
    3. 部分保留， 即 Jap extends Country<East, T> // 发达国家，包含东西方国家
    4. 全部保留， 即 UnKnowCountry extends Country<E, T> // 所有国家
    
- 子类除了可以保留父类的泛型，还可以自己引入泛型
- 泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。换句话说，泛型方法所属的类是不是泛型类都没有关系。即普通类也可以有泛型方法。(详情看UpdateGeneric类的genericMethod方法)
- 泛型方法可以为静态的。原因是，泛型参数是在调用方法时确定的。并非在实例化类时确定的。
- 泛型在继承上的使用
    1. 泛型上不同类型是无法相互赋值（单向）的；是属于并列关系；
    2. 并列关系可以引入 通配符? 作为并列关系的 父类。但是会失去一些特性，如写入功能；特性也会有一定的改变，如读功能（**数据为父类类型**）；
  
- 通配符的限制
  1. ？ extends A 
  2. ？ super A 
  3. 详情看com.generic.UpdateGeneric.testWildCard2方法！！！对通配符进行了限制，对应的功能也会发生改变。
    
- 泛型的作用：
    1. 作用于DAO层，不同的表对于不同的对象映射！
    
